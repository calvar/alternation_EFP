1) Intoduction
   -----------

 a) The problem is how to arange the access of a set of N agents to a limited resource, whose availability is limited to n < N units per turn, given that we want an equal distribution of the resource over time to all agents. That is, which is the pattern that the agents have to follow when accessing the resource such that there is a minimum period of time T over which each agent has accessed the resource the same number of times. We call this access patterns alternations.
 b) Why is alternation important.
 c) A perfect alternation pattern can be obtained with a simple algorithm.
 d) There are many studies that propose algorithms to let agents learn alternation patterns in a distributed way. Our aim however is not to propose a distributed learning algorithm, but rather to let a generator agent to obtain such patterns in an efficient way, and then distribute the pattern to the agents in play as a set of rules for each agent, such that, by following their respective set of rules, the alternation patern can be maintained in a distributed way. 
 
2) Implementation of the alternation scheme
   ----------------------------------------
   
  Once a central agent has generated the alternation pattern, it can be distributed to the set of autonomous agents as a set of rules for each agent.

  A rule set is composed of two parts, a list of neighbors that the agent must observe and a strategy that indicates which action to take given the observed actions of its neighbors in the previous time step.

  Starting from a valid initial configuration, i.e. a configuration present in the alternation pattern, each time step each agent observes the previous states of its neighbors, and then takes the action given by its set of strategies.  

3) Neighbor graphs
   ---------------
   
  The set of neighbor lists of the agents can be represented as a directed graph, where each node represents an agent, and a directed edge from agent i to agent j indicates that i belongs to the neighbor list of j.

  For a given number of agents N and resource units per turn n, there might be several patterns that observe the constraints of equality of distribution and minimum period T. We now observe the characteristics of these solutions for diferent values of N and n. 

  Some of the solutions are such that each agent has a single neighbor. These solutions minimize the amount of information transfer that is needed to maintain the pattern running.

  The minumum number of neighbors per agent is 1, and the patterns of two neighbors are shifted by 1 time unit.  

  In addition, these minimum information solutions, which can be k-partite, contain a single cycle for each independent set.  

  The size of the minumum cycle is the fair period, that is the denominator of the most simplified form of n/N. This fair period is also the number of different patterns in the graph.

  A cycle can only have a size which is a multiple of the number of different patterns, that determines the period of the general pattern. Otherwise the number of shifts won't allow for a periodic pattern.



4) Robustness
   ----------

   As in any distributed system, an agent might go offline for a period of time, which disrupts the alternation pattern. 
   
   Therefore, it is important to devise strategies that allow the system to recuperate when nodes go offline.





# GEMINI TAKE =====================================================

This is a fascinating approach to resource allocation. You are essentially shifting the problem from **online coordination** (which is computationally expensive) to a **structural topology** problem where the schedule is "baked" into the graph's edges.

Here is a first draft of these sections, refined for academic clarity and technical precision.

---

## 1. Introduction

The efficient allocation of scarce resources among competing entities remains a fundamental challenge in multi-agent systems (MAS). Specifically, we address the problem of arranging the access of a set of  autonomous agents to a limited resource with a capacity of  units per time step. Our primary objective is to achieve a **perfectly equal distribution** of resource access across all agents over the minimum possible time horizon. We define these structured sequences of access as **alternation patterns**.

Alternation is critical in systems where fairness directly impacts stability—such as bandwidth allocation, energy sharing in microgrids, or task scheduling in distributed computing. While existing literature often focuses on decentralized learning algorithms to achieve coordination, these methods frequently suffer from high convergence times and communication overhead.

In this paper, we propose a centralized-to-distributed paradigm. A generator agent identifies an optimal alternation pattern and decomposes it into localized rule sets. These rules are then distributed to the agents, allowing the global pattern to emerge and persist through simple, local observations rather than continuous negotiation.

## 2. Implementation of the Alternation Scheme

Once the central generator has calculated a valid alternation pattern, the global sequence is translated into a **distributed protocol**. This protocol is delivered to each agent as a specific **Rule Set** consisting of two components:

1. **Neighbor List:** A subset of agents that the focal agent must monitor.
2. **Strategy Mapping:** A deterministic function that dictates the agent's next action (Access/Wait) based on the observed actions of its neighbors in the preceding time step.

Execution begins from a valid initial configuration—a snapshot of the pre-calculated pattern. From this point, the system operates autonomously. At each time step , every agent  evaluates the state of its neighbors at  and applies its strategy to determine its state at . This mechanism ensures that the global alternation pattern is maintained through local interactions.

## 3. Neighbor Graphs and Topology

The dependencies between agents are modeled as a **Directed Neighbor Graph** , where a directed edge  signifies that agent  monitors agent  to determine its own behavior.

### 3.1. Minimal Information Solutions

A key contribution of this work is identifying patterns that minimize the information transfer required to sustain the period . We find that for various configurations of  and , solutions exist where each agent requires only a **single neighbor** (in-degree = 1). In these "minimalist" solutions, the behavior of agent  is simply a temporal shift (usually by one unit) of agent ’s behavior.

### 3.2. Structural Properties

Our analysis of these graphs reveals several governing principles:

* **Graph Composition:** These minimal solutions are often -partite and consist of independent sets where each set contains a single cycle.
* **The Fair Period:** The fundamental period of access is defined by the denominator of the simplified fraction . This "Fair Period" represents the smallest number of distinct local patterns present in the graph.
* **Cycle Constraints:** To ensure periodicity, any cycle within the neighbor graph must have a length that is a multiple of the number of distinct patterns. If this condition is not met, the temporal shifts will fail to align, and the global pattern will collapse into a non-periodic state.

## 4. Robustness and Recovery

A significant risk in any distributed architecture is the "Offline Node" problem. In a system governed by fixed local rules, the failure of a single agent to act or report its state can cause a cascade of errors, disrupting the entire alternation cycle.

To address this, we explore **recovery strategies** designed to make the system self-healing. These strategies involve:

* **Redundancy:** Incorporating secondary neighbors to provide state verification.
* **Re-synchronization:** Defining "default" behaviors or fallback states that agents can adopt when a neighbor becomes unresponsive, allowing the system to gravitate back toward a stable configuration once the node returns.

---

### Next Steps

Would you like me to **mathematically formalize the Rule Set function** (e.g., using a transition matrix or Boolean functions) or should we move on to drafting the **Results/Case Studies** section for specific values of  and ?